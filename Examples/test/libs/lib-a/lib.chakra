= %(
    init
)

%( io, string ) = /stdlib

init(caps) =
    1 ?
    | 1 ->
        io.print(caps.stdio, string.to-upper("hello world!"))
    | _ ->
        io.print(caps.stdio, string.to-upper("should never happen..."))

; = %(
;     number,
;     string,
;     function
; )

; %(
;     add,
; ) = /stdlib

; number = 1

; string = "Some string"

; function(a) = add(number, a)

; tuple = (number, string)

; struct = %(
;     my-number = 3,
; )

; list = [number, 2, 3]

; map = %[
;     number = string,
;     2 = "Another string"
; ]

; lambda =
;     { (a) ->
;         add(number, a) }

; using-function = function(3)

; make(name, age) =
;     %(
;         name,
;         age
;     )

; complex(fn) =
;     some-num = 42
;     some-string = fn("Hello")
;     (some-num, some-string)


; Uncomment when we add support for spread and struct field access
; zump(struct) =
;     %(
;         num = function(struct),
;         ...struct,
;     )

; print(type) =
;     type ?
;     | #union-type(types) ->
;         types
;         > map(print)
;         > concat(" | ")
;         > format("< %s >") ; This is not a planned feature
;         ; Would desugar to
;         ; format("< %s >", concat(" | ", map(print, types)))

;     | #sum-type(types) ->
;         types
;         > map(print)
;         > concat(" + ")
;         > format("< %s >") ; This is not a planned feature

;     | #string-type -> "str"

;     | #number-type -> "num"

;     | #symbol-type(info) ->
;         info ?
;         | #global-symbol(s) -> format("#%s", s)
;         | #module-symbol(m, s) -> format("#%s/%s", m, s)

;     | #literal-type(literal) -> pretty(80, showLiteral literal)

;     | #tuple-type(type) ->
;         map(print, types)
;         > concat(", ")
;         > format(" %s ")

;     | #list-type(generic-type) ->
;         print(generic-type)
;         > format("[ %s ]")

;     | #map-type(key-type, value-type) ->
;         format("%%[ %s = %s ]", print(key-type), print(value-type))

;     | #struct-type(fields, is-open, tag) ->
;         open-sigil =
;             is-open ?
;             | #true -> "..."
;             | #false -> ""

;         pairs =
;             fields
;             > map({ (name, type) -> format(".%s = %s", name, print(type))})
;             > concat(", ")

;         format("%%( %s %s)", pairs, open-sigil)

;     | #function-type(args, return) ->
;         arg-list =
;             args
;             > map(compose(snd, print))
;             > concat(", ")

;         format("{ %s -> %s }", arg-list, print(return))

;     | #generic-type(type) -> format("?%s", type)

;     | #capability-type(cap) ->
;         cap ?
;         | #stdio-capability -> "$stdio"
;         | #file-read-capability -> "$fread"
;         | #file-write-capability -> "#fwrite"

;     | #command-type -> "!"

;     | #polymorphic-type(t) -> format("@%s", t)

;     | #ref-type(t) -> format("&%s", print(t))